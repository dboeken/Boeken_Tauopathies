
import os
import matplotlib
import random

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from h5py import File
from picasso import io
from picasso import clusterer
from picasso.run import pylocalise
from skimage import io as skio

from loguru import logger
logger.info('Import OK')

root_path = open('raw_data/raw_data.txt', 'r').readlines()[0]

input_parameters = 'results/super-res/initial_cleanup/slide_parameters.csv'
output_folder = f'results/super-res/localisation/'


default_info = {
    'baseline': 100,
    'sensitivity': 1.0000,
    'gain': 55,
    'qe': 1,
    'pixelsize': 107,
}

if not os.path.exists(output_folder):
    os.makedirs(output_folder)


def plot_clusters(image_name, clustered_df, cluster_type='HDBSCAN', output_folder=False):

    cmap = matplotlib.cm.get_cmap('tab10')

    max_clusters = clustered_df[['group']].max().max() + 1
    palette = dict(zip(np.arange(0, max_clusters),
                   cmap.colors*int(max_clusters/10+1)))

    kws = {"s": 50, "facecolor": "none", "linewidth": 1.5}

    fig, axes = plt.subplots(figsize=(15, 15))
    sns.scatterplot(
        data=clustered_df,
        x='x',
        y='y',
        ax=axes,
        edgecolor=clustered_df[clustered_df['group']
                               != -1]["group"].map(palette),
        **kws,
    )
    axes.legend("")
    axes.set_title(
        f"{image_name} {cluster_type} total clusters: {clustered_df['group'].max()+1}")
    if output_folder:
        plt.savefig(f'{output_folder}clusters_{image_name}.png')

    return axes


def localise_locs(output_folder, parameters, threshold=15000, drift=900, trim=250, visualise=2):
    for filepath, layout, well_info in parameters[['file_path', 'layout', 'well_info']].values:
        if f'{layout}_{well_info}_locs.hdf5' in os.listdir(output_folder):
            continue
        logger.info(f'Processing {layout} {well_info}')
        try:
            pylocalise(filepath, image_name=well_info, output_folder=f'{output_folder}{layout}_',
                       drift_frames=drift, trim=trim, visualise=visualise, minimum_ng=threshold, box=7)
        except:
            logger.info(f'Processing {well_info} failed')


def filter_locs(output_folder, precision_threshold, parameters):
    for well_info, layout in parameters[['well_info', 'layout']].values:
        try:
            locs, info = io.load_locs(
                f'{output_folder}{layout}_{well_info}_locs_corr.hdf5')

            logger.info(f'Loaded {len(locs)} locs for {layout} {well_info}.')
        except:
            logger.info(f'No locs found for {layout} {well_info}')
            continue

    # ## Filter localizations
    # Filter localizations, i.e., via lpx and lpy: Remove all localizations that have a maximum precision > 10 nm.
        to_keep = locs.lpx * locs.lpy < precision_threshold
        filtered_locs = locs[to_keep]
        logger.info(f'After filtering {len(filtered_locs)}.')

    # ## Saving localizations
    # Add new info to the yaml file and save everything.
    # Create a new dictionary for the new info
        new_info = {}
        new_info["Generated by"] = "Picasso Jupyter Notebook"
        new_info["Filtered"] = 'Precision'
        new_info["lp_threshold"] = precision_threshold
        info.append(new_info)

        io.save_locs(
            f'{output_folder}{layout}_{well_info}_locs_corr_filt.hdf5', filtered_locs, info)

        logger.info(f'{len(filtered_locs)} locs saved.')


def cluster_optimisation(output_folder, test_wells):
    optimisation = []
    plots = []
    for well_info in test_wells:
        try:
            locs, info = io.load_locs(
                f'{output_folder}{well_info}_locs_corr_filt.hdf5')
        except:
            logger.info(f'No locs found for {well_info}')
            continue
        for radius in np.arange(0.1, 1.1, 0.2):
            for min_size in [2, 5, 10]:
                # # Calculating clusters
                try:
                    locs = clusterer.dbscan(
                        locs, radius=radius, min_density=min_size, pixelsize=107)
                    logger.info(
                        f'{len(pd.DataFrame(locs)["group"].unique())} clusters identified.')
                    optimisation.append([well_info, 'DBSCAN', radius, min_size, len(
                        pd.DataFrame(locs)['group'].unique())])
                except:
                    logger.info(f'Unable to cluster {well_info}')

    optimisation = pd.DataFrame(optimisation, columns=[
                                'well_info', 'cluster_method', 'radius', 'min_size', 'num_clusters'])
    optimisation.to_csv(f'{output_folder}clustering_optimisation.csv')

    return optimisation


def plot_cluster_optimisation(output_folder, parameters, optimisation):
    palette = {2: '#06BCC1', 3: '#FFC145',
               4: '#FF6B6B', 5: '#AF125A', 10: '#12263A'}
    sample_names = dict(parameters[['well_info', 'sample']].values)

    for well_info, df in optimisation.groupby('well_info'):
        max_val = df['num_clusters'].max()
        fig, axes = plt.subplots(1, 2, figsize=(11, 5))
        sns.lineplot(
            data=df[df['cluster_method'] == 'HDBSCAN'],
            x='radius',
            y='num_clusters',
            hue='min_size',
            palette=palette,
            ax=axes[0]
        )
        axes[0].set_title('HDBSCAN')
        axes[0].legend("")
        axes[0].set_ylim(0, max_val)
        sns.lineplot(
            data=df[df['cluster_method'] == 'DBSCAN'],
            x='radius',
            y='num_clusters',
            hue='min_size',
            palette=palette,
            ax=axes[1]
        )
        axes[1].set_title('DBSCAN')
        axes[1].legend(title='Minimum density')
        axes[1].set_ylim(0, max_val)
        plt.ylabel('Number of clusters')
        plt.xlabel('EPS parameter')
        plt.savefig(f'{output_folder}{well_info}_optimisation.png')
        plt.suptitle(sample_names[f'{well_info}'])
        plt.tight_layout()
        plt.show()


def cluster_locs(output_folder, visualise, parameters, radius, min_density):
    dbscan_info = {
        "Generated by": "Picasso DBSCAN",
        "Radius": radius,
        "Min cluster size": min_density,
    }
    for well_info, layout in parameters[['well_info', 'layout']].values:
        try:
            locs, info = io.load_locs(
                f'{output_folder}{layout}_{well_info}_locs_corr_filt.hdf5')
        except:
            logger.info(f'No locs found for {layout} {well_info}')
            continue
        if len(locs) < min_density:
            logger.info(f'Not enough locs found for {layout} {well_info}')
            continue
    # Calculating clusters with DBSCAN
        locs, info = io.load_locs(
            f'{output_folder}{layout}_{well_info}_locs_corr_filt.hdf5')
        locs = clusterer.dbscan(locs, radius=radius,
                                min_density=min_density, pixelsize=107)
        logger.info(
            f'{len(pd.DataFrame(locs)["group"].unique())} clusters identified.')

    # Save
        info.append(dbscan_info)
        io.save_locs(
            f"{output_folder}{layout}_{well_info}_dbscan.hdf5", locs, info)
        with File(f"{output_folder}{layout}_{well_info}__dbclusters.hdf5", "w") as clusters_file:
            clusters_file.create_dataset("clusters", data=locs)

        locs = pd.DataFrame(locs)
        locs.to_csv(f"{output_folder}{layout}_{well_info}_dbclusters.csv")

        if well_info in visualise:
            if len(locs) > 0:
                plot_clusters(well_info, locs)


def plot_projection(raw_image_path, imrange=None, vmax=20000, output_folder=False):

    well_info = raw_image_path.split('/')[-1].replace('.tif', '')
    if not imrange:
        key = None
    else:
        key = np.arange(imrange[0], imrange[1])
    raw_image = skio.imread(raw_image_path, key=key)
    raw_image.shape
    # plt.imshow(raw_image[0, :, :], cmap='Greys_r')

    fig, axes = plt.subplots(figsize=(15, 15))
    max_projection = np.max(raw_image, axis=0)
    plt.imshow(max_projection, cmap='Greys_r', vmax=vmax)
    plt.axis('off')
    if output_folder:
        plt.savefig(f'images/example_maxproj_{well_info}.png')

    return max_projection


def plot_proj_clusters(output_folder, raw_image_path, radius, min_density, imrange=None, vmax=None):

    well_info = raw_image_path.split('/')[-1].replace('.tif', '')
    max_projection = plot_projection(raw_image_path, imrange, vmax)
    plt.show()

    locs, info = io.load_locs(
        f'{output_folder}{well_info}_locs_corr_filt.hdf5')
    locs = clusterer.dbscan(locs, radius=radius,
                            min_density=min_density, pixelsize=107)
    locs = pd.DataFrame(locs)

    cmap = matplotlib.cm.get_cmap('tab10')

    max_clusters = locs[['group']].max().max() + 1
    palette = dict(zip(np.arange(0, max_clusters),
                   cmap.colors*int(max_clusters/10+1)))

    kws = {"s": 200, "facecolor": "none", "linewidth": 1.5}

    fig, axes = plt.subplots(figsize=(15, 15))
    axes.imshow(max_projection, cmap='Greys_r', vmax=vmax)
    sns.scatterplot(
        data=locs,
        x='x',
        y='y',
        ax=axes,
        edgecolor=locs[locs['group'] != -1]["group"].map(palette),
        **kws,
    )
    axes.legend("")
    plt.axis('off')

    axes.set_title(f"{well_info} total clusters: {locs['group'].max()+1}")
    plt.savefig(f'images/example_clusters_{well_info}.png')

    return locs


def locs_optimiser(parameters, output_folder, filepath, thresholds=[15000], drift=900, trim=250, visualise=0, precision=10, pixel_size=107, radius=2, min_density=2, imrange=None, vmax=None):
    well_info = filepath.split('/')[-1].replace('.tif', '')
    test_parameters = parameters[parameters['file_path'] == filepath].copy()

    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

    locs = {}
    for threshold in thresholds:
        pylocalise(filepath, image_name=well_info, output_folder=output_folder,
                   drift_frames=drift, trim=trim, visualise=visualise, minimum_ng=threshold, box=7)
        plt.show()

        filter_locs(output_folder, precision_threshold=(
            precision/pixel_size), parameters=test_parameters)

        optimisation = cluster_optimisation(
            output_folder, test_wells=[well_info])
        plot_cluster_optimisation(output_folder, test_parameters, optimisation)
        plt.show()
        locs[threshold] = plot_proj_clusters(
            output_folder, raw_image_path=filepath,
            radius=radius, min_density=min_density,
            imrange=imrange, vmax=vmax
        )

    return locs


# Compile list of files to be processed
parameters = pd.read_csv(input_parameters)
parameters.drop([col for col in parameters.columns.tolist()
                if 'Unnamed: ' in col], axis=1, inplace=True)
parameters.dropna(subset=['keep'], inplace=True)

layouts = {
    '': '1',
    '2': '2',
}
parameters['layout'] = parameters['file_path'].str.split(
    '/').str[-2].map(layouts)


test_path = parameters['file_path'][7]
test_output = 'images/test-localisation/'

locs = locs_optimiser(
    parameters, output_folder=test_output, filepath=test_path,
    # localisation params
    thresholds=[45000], drift=900, trim=250, visualise=0,
    precision=10, pixel_size=107,  # filtering params
    radius=0.3, min_density=5,  # clustering params
)


# optimised parameters
threshold = 45000
precision_threshold = 10 / 107
radius = 0.3
min_density = 5
channel = 641
# ----------------------Localise----------------------
localise_locs(output_folder, parameters, threshold=threshold,
              drift=900, trim=100, visualise=0)

# ------------------------Filter------------------------
filter_locs(output_folder, precision_threshold, parameters)

# ----------------Cluster with DBSCAN----------------
visualise = random.sample(list(parameters[parameters['channel'] == channel]['well_info'].values), 10)
cluster_locs(output_folder=output_folder, parameters=parameters, radius=radius, min_density=min_density, visualise=visualise)
logger.info('Clustering complete')


# -------Plot example clustering vs projection images-------
well_info = 'X2Y3R1W1_641'
raw_image_path = parameters[parameters['well_info']
                            == well_info]['file_path'].tolist()[0]
max_projection = plot_projection(well_info, raw_image_path)

# Plot DBSCAN clusters
plot_proj_clusters(output_folder, raw_image_path, radius, min_density)
